# RRT

A simple and extensible Rust library implementing Rapidly-Exploring Random Trees for robot motion planning.

## Demo in 2D 
![GIF of RRT in 2D](https://raw.githubusercontent.com/Priyanshu4/rrt/refs/heads/demo-gif/examples/rrt2d_demo.gif)

The GIF above is generated by `examples/rrt2d.rs`.
It uses a point robot, spherical obstacles, a uniform sampling distribution with 5% goal bias and a straight line steering mechanism.
The red path shows the path found by RRT. The green path is after applying shortcutting with `rrt::smoothing::fast_shortcutting`.

## Using RRT for your own robots
The RRT library is designed to be applicable to a wide variety of robots. Therefore, we use generic parameters.
To use an RRT you will need to implement and specify the following generics.
- F (`num_traits::Float`) : the floating point type (implements num_traits::Float)
- N (`usize`) : the number of dimensions in the state space 
- VC (`rrt::ValidityChecker`) : provides functions to check if points and edges in state space are valid (not in collision)
    - Your implementation should consider the geometry of your robot and the environment
      - If you are planning in joint space for a serial manipulator, this will need to perform forward kinematics for collision checking
- SD (`rrt::SamplingDistribution`) : provides a function to sample points from the state space
    - For most applications, `rrt::GoalBiasedUniformDistribution` is sufficient
- ST (`rrt::Steering`) : provides a function to generate a new point by steering from one point towards the direction of another
    - For applications in which you do not care about robot dynamics, `rrt::EuclideanSteering` is sufficient
- NN: (`rrt::NearestNeighbors`) : data structure for efficient nearest neighbors
    - For most applications, `rrt::KdTreeNearestNeighbors` is sufficient (implemented using `kiddo` library)

